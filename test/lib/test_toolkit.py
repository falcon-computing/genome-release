#!/usr/bin/env python2.7
# Chris Eisenhart chrisEisenhart1992@gmail.com
"""
Test the falcon toolkit, runs all pipelines on the input files.

The user can provide an output directory which has expected output files that will be 
compared to the generated files. 
"""
import sys
import operator
import argparse
import subprocess
import os
import falconCommonTest
import shutil
import logging
logging.basicConfig(level=logging.INFO)


def parseArgs(args): 
    """ 
    Sets up the argparse command-line parser and calls it. These options can be accessed
    using args.option. For example args.a stores the alphabet provided. 
    """
    parser = argparse.ArgumentParser(description = __doc__)
    parser.add_argument ("build",
            help = "Path to fcs-genome toolkit that should be tested",
            action = "store")
    parser.add_argument ("reference_genome",
            help = "Path to a reference.fasta file, it is assumed necessary indeces are there (.fai, .bwt, etc)",
            action = "store")
    parser.add_argument ("expected_output_dir",
            help = "Directory that holds expected output files the generated ones should be compared too",
            action = "store")
    parser.add_argument ("fastq_R1",
            help = "The R1 fastq file",
            action = "store")
    parser.add_argument ("fastq_R2",
            help = "The R2 fastq file",
            action = "store")
    parser.add_argument ("known_SNPs",
            help = "Known variants that should be used for base recalibration (vcf file)",
            action = "store")
    parser.add_argument ("tumor_bam",
            help = "Tumor bam file for mutect variant calling",
            action = "store")
    parser.add_argument ("gvcf_dir",
            help = "gvcf directory for joint variant calling",
            action = "store")
    parser.add_argument ("normal_panel_vcf",
            help = "vcf for mutect gatk4 variant calling",
            action = "store")
    parser.add_argument ("gnomad_vcf",
            help = "vcf for mutect gatk4 variant calling",
            action = "store")
    # Optional variables
    parser.add_argument ("--timeout",
            help = "Time limit for each step",
            action = "store")
    parser.add_argument("--verbose",
            # Sets warning tags to on
            help = "The program will send warning messages to stderr. This is very messy, use with caution.",
            action= "store_false")
    parser.add_argument("--no_comparison",
            help = "Do not compare to the expected output files",
            action= "store_true")
    parser.add_argument("--hard_remove_files",
            help = "Remove generated files even if they fail comparison",
            action= "store_true")
    parser.add_argument("--no_remove_files",
            help = "Remove generated files even if they fail comparison",
            action= "store_true")

    parser.set_defaults(no_comparison = False)
    parser.set_defaults(timeout = 50)
    args = parser.parse_args() # Initializes the options specified above
    return args # Returns the parser as an object


def main(args):
    """
    This is mostly a wrapper script for functions found in falconCommonTest.  This script
    runs the best practices pipeline on a single sample and tracks the run times. 
    """
    options = parseArgs(args)

    # Input files
    fcs_genome = options.build
    ref = options.reference_genome
    known_snps = options.known_SNPs
    fastq1 = options.fastq_R1
    fastq2 = options.fastq_R2
    tumor_bam = options.tumor_bam
    gvcf_dir = options.gvcf_dir
    normal_panel_vcf = options.normal_panel_vcf
    gnomad_vcf = options.gnomad_vcf
    expected_dir = options.expected_output_dir
    timeout = int(options.timeout)

    # Create a dictionary that maps variable names to a file name. All these files should
    # be generated by testing and need to be compared and removed later.
    generic_fn = fastq1.replace(".gz", "").replace(".fastq", "").split("/")[-1].split("_")[0]

    #Run the various components of the pipeline and track their run times.
    align_time = falconCommonTest.test_align(fcs_genome, timeout, expected_dir, ref, fastq1, fastq2, generic_fn + ".bam")
    bqsr_time = falconCommonTest.test_bqsr(fcs_genome, timeout, expected_dir, ref, known_snps, generic_fn)
    htc_time = falconCommonTest.test_htc(fcs_genome, timeout, expected_dir, ref, generic_fn)
    mutect2_time = falconCommonTest.test_mutect2(fcs_genome, timeout, expected_dir, ref, generic_fn, tumor_bam, known_snps)
    joint_time = falconCommonTest.test_joint(fcs_genome, timeout, expected_dir, ref, gvcf_dir, generic_fn, known_snps)
    ug_time = falconCommonTest.test_ug(fcs_genome, timeout, expected_dir, ref, generic_fn, known_snps)
    germline_time = falconCommonTest.test_germline(fcs_genome, timeout, expected_dir, ref, fastq1, fastq2, known_snps, generic_fn)
    htc_4_time = falconCommonTest.test_htc(fcs_genome, timeout, expected_dir, ref, generic_fn, use_GATK4=True)
    mutect2_4_time = falconCommonTest.test_mutect2(fcs_genome, timeout, expected_dir, ref, generic_fn, tumor_bam, known_snps,
                                                   use_GATK4=True, normal_panel_vcf=normal_panel_vcf, gnomad_vcf=gnomad_vcf)
    joint_4_time = falconCommonTest.test_joint(fcs_genome, timeout, expected_dir, ref, gvcf_dir, generic_fn, known_snps, use_GATK4=True)
    germline_4_time = falconCommonTest.test_germline(fcs_genome, timeout, expected_dir, ref, fastq1, fastq2, known_snps, generic_fn, use_GATK4=True)

    shutil.rmtree("log", ignore_errors=True)

    stats_table = ["Run time table;",
                   "Command\tTime/Status",
                   "align\t{}".format(align_time),
                   "bqsr\t{}".format(bqsr_time),
                   "htc\t{}".format(htc_time),
                   "mutet2\t{}".format(mutect2_time),
                   "joint\t{}".format(joint_time),
                   "ug\t{}".format(ug_time),
                   "germline\t{}".format(germline_time),
                   "htc_4\t{}".format(htc_4_time),
                   "mutect2_4\t{}".format(mutect2_4_time),
                   "joint_4\t{}".format(joint_4_time),
                   "germline_4\t{}".format(germline_4_time)
                  ]
    logging.info("{}".format("\n".join(stats_table)))

    if "failed" or "mangled" or "skipped" in stats_table: return 1


if __name__ == "__main__" :
    sys.exit(main(sys.argv))
